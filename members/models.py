import bleach

from random import randint
from PIL import Image
from pathlib import Path
from hashlib import sha256
from os import remove

from django.db import models
from django.core.files.storage import FileSystemStorage
from django.conf import settings
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver


def avatar_image_path(instance, filename):
    # Previously user's avatar images were stored using their username as the file name. However, as the username is
    # their University ID, this would expose a user's University ID to anyone who could see the filename for their
    # avatar. To fix this, the filename is now a hash of the username.
    file_name = sha256(instance.user.username.encode('utf-8')).hexdigest()
    return Path('user_avatars', '{0!s}{1!s}'.format(file_name, '.png'))


class OverwriteStorage(FileSystemStorage):
    def get_available_name(self, name, max_length=None):
        """Returns a filename that's free on the target storage system, and available for new content to be written to.

        Found at http://djangosnippets.org/snippets/976/

        This file storage solves overwrite on upload problem. Another proposed solution was to override the save method
        on the model like so (from https://code.djangoproject.com/ticket/11663):

        def save(self, *args, **kwargs):
            try:
                this = MyModelName.objects.get(id=self.id)
                if this.MyImageFieldName != self.MyImageFieldName:
                    this.MyImageFieldName.delete()
            except: pass
            super(MyModelName, self).save(*args, **kwargs)
        """

        # If the filename already exists, remove it as if it was a true file system
        if self.exists(name):
            remove(Path(settings.MEDIA_ROOT, name))
        return name


def get_random_nickname():
    # A random nickname is generated by default for each new member. This is done to prevent someones full name, or
    # University ID from leaking.
    return 'Buster Machine #{0!s}'.format(randint(0, 1000000))


# Member model is almost identical to the one from aniMango for compatibility, however there have been a few changes
# which are as follows:
#   In this version the bio field has been removed as it was unused by most users.
#   The nick field has been renamed to nickname for clarity
#   The img, field has been renamed to avatar_image for clarity
#   The img_height and img_width fields have been removed as they were unused
#   The disordTag field has been renamed to discord_tag for consistency
# These changes mean that restoring the site DB to a backup from the old site will require reformatting the backup
# SQL file. However this should not be an issue following the initial DB transfer.
class Member(models.Model):
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        primary_key=True
    )

    # Setting nickname by default prevents someone's full name or University ID from leaking.
    nickname = models.CharField(max_length=30, blank=True, default=get_random_nickname)
    show_full_name = models.BooleanField(default=False)
    avatar_image = models.ImageField(upload_to=avatar_image_path, storage=OverwriteStorage(), blank=True, null=True)
    discord_tag = models.CharField(max_length=40, blank=True)

    def __str__(self):
        # Each user's Username is their University ID this is somewhat sensitive data, so it is never shown.
        # Instead, users nicknames will be displayed by default. If the user has chosen to display their full name
        # (show_full_name is set to True) their full name will be displayed instead.
        # In the rare case where a user has no nickname (i.e they set it to blank themselves) and they have chosen not
        # to show their full name, their first name will be displayed, as this is the least sensitive data that could
        # be shown.
        if self.show_full_name:
            return self.user.get_full_name()
        elif self.nickname:
            return self.nickname
        else:
            return self.user.get_short_name()

    def is_privileged(self):
        return self.user.groups.filter(name='President').exists() or self.user.is_superuser

    def save(self, *args, **kwargs):
        # Strip all HTML from nickname and discord_tag.
        self.nickname = bleach.clean(self.nickname, tags=[], attributes={}, styles=[], strip=True)
        self.discord_tag = bleach.clean(self.discord_tag, tags=[], attributes={}, styles=[], strip=True)

        super(Member, self).save(*args, **kwargs)

        # Resize and save avatar_image.
        # All images used will be converted to jpg, this removes the need to delete an old avatar with a different file
        # extension.
        image_dimensions = (512, 512)
        if self.avatar_image:
            try:
                new_avatar = Image.open(self.avatar_image.path)
                # Images should only be resized if necessary. Rectangular images will be cropped to be square.
                avatar_width, avatar_height = new_avatar.size
                if avatar_width != image_dimensions[0] or avatar_height != image_dimensions[1]:
                    # Crop the largest square possible.
                    smallest_side_by_half = min((avatar_width, avatar_height)) / 2
                    avatar_width_by_half = avatar_width / 2
                    avatar_height_by_half = avatar_height / 2
                    new_avatar = new_avatar.crop((avatar_width_by_half - smallest_side_by_half,
                                                  avatar_height_by_half - smallest_side_by_half,
                                                  avatar_width_by_half + smallest_side_by_half,
                                                  avatar_height_by_half + smallest_side_by_half)
                                                 ).resize(image_dimensions, Image.ANTIALIAS)
                    new_avatar.save(self.avatar_image.path, quality=90, format='PNG')
                    super(Member, self).save(*args, **kwargs)
            except Exception as e:
                raise


# Ensure that a new Member object is created for each user using the post_save signal.
# See https://coderwall.com/p/ktdb3g/django-signals-an-extremely-simplified-explanation-for-beginners
@receiver(post_save, sender=User)
def ensure_member_exists(sender, instance, created, **kwargs):
    if created:
        Member.objects.get_or_create(user=instance)
